# -*- coding: utf-8 -*-
"""q2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HoI_6UV5EZpJaSvfqbz5nSy_QgY4OZ_C

Design Strategy:
Divide and Conquer Approach:

Divide the set of points into two halves.
Recursively find the maxima set in each half.
Combine the maxima sets of the two halves to get the final maxima set.
Base Case:

If the set of points has only one or two points, return the set itself as the maxima set.
Combining Step:

After finding the maxima sets of the two halves, combine them by comparing the maxima points of each half.


Running Time Complexity:
Let T(n) be the running time of the algorithm on a set of n points.

The recurrence relation for the time complexity is T(n)=2T(n/2)+O(n), which is a standard form for divide and conquer algorithms.
The divide step takes O(1) time.
The combine step takes O(n) time as it involves finding the maximum y-coordinates.
By the Master Theorem, the time complexity of the algorithm is O(nlogn).

Base Case: Prove that the algorithm is correct for the base case (sets of size 1 and 2).
Inductive Step: Assume that the algorithm is correct for sets of size k (inductive hypothesis) and then prove that it's correct for sets of size 2k.
Base Case:
Case 1:
n=1
For a set of size 1, the algorithm trivially returns the set itself, and it's correct.

Case 2:
n=2
For a set of size 2, the algorithm returns the point with the maximum y-coordinate, and it's correct.

Inductive Step:
Inductive Hypothesis:
Assume that the algorithm is correct for sets of size k.

Inductive Goal:
Prove that the algorithm is correct for sets of size 2k.

Proof:
Consider a set S of size 2k, where S=S1âˆªS2, with S1 and S2 being the left and right halves of S (as per the divide step of the algorithm).

Recursion: By the inductive hypothesis, the algorithm correctly finds the maxima sets for S1 and S2.

Combining Step:

Let P1 be the maxima set for S1 and P2 be the maxima set for S2.
Find the points with the maximum y-coordinates in P1 and P2, denoted as Q1 and Q2 respectively.
If Q1 has a higher y-coordinate than Q2,then P1 is the correct maxima set for S.
If Q2 has a higher y-coordinate than Q1, then P2 is the correct maxima set for S.
If Q1 and Q2 have the same y-coordinate, then both P1 and P2 are correct maxima sets for S.
This completes the inductive step. Therefore, by mathematical induction, the algorithm is correct for sets of any size.
"""

import time

def find_maxima_set(points):
    if len(points) <= 1:
        return points

    print(f"Dividing: {points}")

    start_time = time.time()

    mid = len(points) // 2
    left_half = find_maxima_set(points[:mid])
    right_half = find_maxima_set(points[mid:])

    end_time = time.time()
    print(f"Runtime for dividing: {end_time - start_time:.6f} seconds")

    return merge_maxima_sets(left_half, right_half)

def merge_maxima_sets(left_set, right_set):
    merged_set = []

    i, j = 0, 0
    while i < len(left_set) and j < len(right_set):
        x1, y1 = left_set[i]
        x2, y2 = right_set[j]

        if x1 > x2 and y1 > y2:
            merged_set.append(left_set[i])
            i += 1
        elif x1 < x2 and y1 < y2:
            merged_set.append(right_set[j])
            j += 1
        else:
            # If the points are incomparable, choose the one with a smaller x-coordinate
            if x1 <= x2:
                merged_set.append(left_set[i])
                i += 1
            else:
                merged_set.append(right_set[j])
                j += 1

    # Add the remaining points from both sets
    merged_set.extend(left_set[i:])
    merged_set.extend(right_set[j:])

    print(f"Merging: {merged_set}")
    return merged_set

# Test case
points = [(1, 2), (3, 1), (2, 4), (5, 3), (4, 6)]

start_time = time.time()
result = find_maxima_set(points)
end_time = time.time()

print("\nFinal Maxima Set:", result)
print(f"Total Runtime: {end_time - start_time:.6f} seconds")

import time
import random

def generate_random_points(num_points, max_coordinate):
    return [(random.randint(1, max_coordinate), random.randint(1, max_coordinate)) for _ in range(num_points)]

def find_maxima_set(points):
    if len(points) <= 1:
        return points

    print(f"Dividing: {points}")

    start_time = time.time()

    mid = len(points) // 2
    left_half = find_maxima_set(points[:mid])
    right_half = find_maxima_set(points[mid:])

    end_time = time.time()
    print(f"Runtime for dividing: {end_time - start_time:.6f} seconds")

    return merge_maxima_sets(left_half, right_half)

def merge_maxima_sets(left_set, right_set):
    merged_set = []

    i, j = 0, 0
    while i < len(left_set) and j < len(right_set):
        x1, y1 = left_set[i]
        x2, y2 = right_set[j]

        if x1 > x2 and y1 > y2:
            merged_set.append(left_set[i])
            i += 1
        elif x1 < x2 and y1 < y2:
            merged_set.append(right_set[j])
            j += 1
        else:
            # If the points are incomparable, choose the one with a smaller x-coordinate
            if x1 <= x2:
                merged_set.append(left_set[i])
                i += 1
            else:
                merged_set.append(right_set[j])
                j += 1

    # Add the remaining points from both sets
    merged_set.extend(left_set[i:])
    merged_set.extend(right_set[j:])

    print(f"Merging: {merged_set}")
    return merged_set

# Test case with random points
random_points = generate_random_points(num_points=10, max_coordinate=10)

start_time = time.time()
result = find_maxima_set(random_points)
end_time = time.time()

print("\nFinal Maxima Set:", result)
print(f"Total Runtime: {end_time - start_time:.6f} seconds")

