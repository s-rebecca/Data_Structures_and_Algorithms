# -*- coding: utf-8 -*-
"""q4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IK_ObpPNgvxVyJDZOF6Z7OANpgDemScO
"""

def valid_partition(S, k, max_sum):
    current_sum = 0
    partitions = 1

    for num in S:
        current_sum += num
        if current_sum > max_sum:
            current_sum = num
            partitions += 1

    return partitions <= k

def integer_partition(S, k):
    S.sort()
    low, high = S[0], sum(S)

    while low < high:
        mid = (low + high) // 2
        if valid_partition(S, k, mid):
            high = mid
        else:
            low = mid + 1

    result = []
    current_sum = 0
    current_partition = []

    for num in S:
        current_sum += num
        if current_sum > low:
            result.append(current_partition)
            current_partition = [num]
            current_sum = num
        else:
            current_partition.append(num)

    result.append(current_partition)
    return result

S1 = [100, 200, 300, 400, 500, 600, 700, 800, 900]
k1 = 3

S2 = [100, 100, 100, 100, 100, 100, 100, 100, 100]
k2 = 3

S3 = [50, 100, 150, 200, 250, 300]
k3 = 2

S4 = [10]
k4 = 1

S5 = [50, 50, 50, 50, 50]
k5 = 2

S6 = [1000, 2000, 3000, 4000, 5000]
k6 = 2

print("Test Case 1:", integer_partition(S1, k1))
print("Test Case 2:", integer_partition(S2, k2))
print("Test Case 3:", integer_partition(S3, k3))
print("Test Case 4:", integer_partition(S4, k4))
print("Test Case 5:", integer_partition(S5, k5))
print("Test Case 6:", integer_partition(S6, k6))

def integer_partition_dp(S, k):
    n = len(S)

    # Initialize DP table
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0

    # Fill DP table
    for i in range(1, n + 1):
        for j in range(1, k + 1):
            for l in range(1, i + 1):
                dp[i][j] = min(dp[i][j], max(dp[l][j - 1], sum(S[l-1:i])))

    # Backtrack to construct partition
    partitions = []
    i, j = n, k
    while j > 0 and i > 0:  # Fix the loop condition
        max_sum = float('inf')
        partition = []
        while i > 0:
            max_sum = min(max_sum, max(dp[i][j - 1], sum(S[i-1:])))
            if dp[i][j] == max_sum:
                partition = S[i - 1:i] + partition
                j -= 1
            i -= 1
        partitions.append(partition)

    partitions.reverse()
    return partitions

# Test cases
S1 = [100, 200, 300, 400, 500, 600, 700, 800, 900]
k1 = 3

S2 = [100, 100, 100, 100, 100, 100, 100, 100, 100]
k2 = 3

S3 = [50, 100, 150, 200, 250, 300]
k3 = 2

S4 = [10]
k4 = 1

S5 = [50, 50, 50, 50, 50]
k5 = 2

S6 = [1000, 2000, 3000, 4000, 5000]
k6 = 2

print("Test Case 1:", integer_partition_dp(S1, k1))
print("Test Case 2:", integer_partition_dp(S2, k2))
print("Test Case 3:", integer_partition_dp(S3, k3))
print("Test Case 4:", integer_partition_dp(S4, k4))
print("Test Case 5:", integer_partition_dp(S5, k5))
print("Test Case 6:", integer_partition_dp(S6, k6))