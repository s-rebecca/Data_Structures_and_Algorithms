# -*- coding: utf-8 -*-
"""q1ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LU6wU8BdbaAhNVwr5gXL4ZpXWN0hYzo1
"""

import random

# Function to generate a random enemy_relations dictionary for testing
def generate_random_test_case(num_friends, max_enemies):
    friends = [chr(ord('A') + i) for i in range(num_friends)]
    enemy_relations = {friend: set() for friend in friends}

    for friend in friends:
        num_enemies = random.randint(0, max_enemies)
        enemies = random.sample(list(set(friends) - {friend}), num_enemies)
        enemy_relations[friend].update(enemies)

        for enemy in enemies:
            enemy_relations[enemy].add(friend)

    return enemy_relations

# Greedy Algorithm
def invite_friends_greedy(enemy_relations):
    invited_friends = set()
    sorted_friends = sorted(enemy_relations.keys(), key=lambda friend: len(enemy_relations[friend]))
    for friend in sorted_friends:
        if not any(e in invited_friends for e in enemy_relations[friend]):
            invited_friends.add(friend)
    return invited_friends

#cases where selecting a friend with more enemies at a certain step leads to a larger overall
#set of friends, it would demonstrate that the greedy algorithm is not always optimal.

# Dynamic Programming
def invite_friends_dp(enemy_relations):
    friends = sorted(enemy_relations.keys())
    dp = [0] * (len(friends) + 1)
    for i in range(1, len(friends) + 1):
        dp[i] = dp[i - 1]
        for j in range(i - 1, -1, -1):
            if all(friends[i - 1] not in enemy_relations[friends[k]] for k in range(j, i - 1)):
                dp[i] = max(dp[i], 1 + dp[j])
                break

    # Backtrack to find the optimal set
    optimal_set = set()
    i = len(friends)
    while i > 0:
        if dp[i] != dp[i - 1]:
            optimal_set.add(friends[i - 1])
            i -= 2
        else:
            i -= 1

    return optimal_set

# Backtracking
def invite_friends_backtracking_helper(friends, enemy_relations, current_set, optimal_set, index):
    if index == len(friends):
        if len(current_set) > len(optimal_set):
            optimal_set.clear()
            optimal_set.update(current_set)
        return

    # Include friend at index
    include = True
    for friend in current_set:
        if friends[index] in enemy_relations[friend] or friend in enemy_relations[friends[index]]:
            include = False
            break

    if include:
        current_set.add(friends[index])
        invite_friends_backtracking_helper(friends, enemy_relations, current_set, optimal_set, index + 1)
        current_set.remove(friends[index])

    # Exclude friend at index
    invite_friends_backtracking_helper(friends, enemy_relations, current_set, optimal_set, index + 1)

def invite_friends_backtracking(enemy_relations):
    friends = sorted(enemy_relations.keys())
    current_set = set()
    optimal_set = set()
    invite_friends_backtracking_helper(friends, enemy_relations, current_set, optimal_set, 0)
    return optimal_set

# Test with a random test case
random_test_case = generate_random_test_case(num_friends=10, max_enemies=5)
print("Random Test Case:", random_test_case)

greedy_solution = invite_friends_greedy(random_test_case)
print("Greedy Solution:", greedy_solution)

dp_solution = invite_friends_dp(random_test_case)
print("Dynamic Programming Solution:", dp_solution)

backtracking_solution = invite_friends_backtracking(random_test_case)
print("Backtracking Solution:", backtracking_solution)